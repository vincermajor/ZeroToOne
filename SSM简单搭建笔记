SSM整合

一. 功能点

分页
数据校验
ajax
Rest风格的URI;使用HTTP协议请求方式的动词，来表示对资源的操作(GET(查询),POST(新增),PUT(修改),DELETE(删除))
二. 技术点

基础框架-ssm(SpringMVC+Spring+MyBatis)
数据库-MySQL
前端框架-bootstrap快速搭建简洁美观界面
项目的依赖管理-Maven
分页-pagehelper
逆向工程-MyBatis Generator
三. 基础环境搭建

0. 配置maven

(1) maven安装目录下conf/setting.xml添加

<mirror>
	<id>alimaven</id>
	<name>aliyun maven</name>
	<url>http://maven.aliyun.com/nexus/content/groups/public/</url>
	<mirrorOf>central</mirrorOf>
</mirror>
<profile>
  <id>jdk-1.8</id>
  <activation>
	<activeByDefault>true</activeByDefault>
    <jdk>1.8</jdk>
  </activation>
  <properties>
	<maven.compiler.source>1.8</maven.compiler.source>
	<maven.compiler.target>1.8</maven.compiler.target>
	<maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion>
  </properties>
</profile>
(2) eclipse配置maven

Window --> Preference --> Maven --> User Settings --> Global Settings全局用户(User Settings当前用户) --> maven安装目录/conf/settings.xml --> Update Settings --> Apply And Close
(3) eclipse更改编码格式

Window --> Preference --> General --> Workspace --> UTF-8
	Window --> Preference --> General --> Content Types --> Text --> Java Properties File(Java Source File) --> UTF-8
	Window --> Preference --> Web --> jsp --> UTF-8
1. 创建一个maven工程

(1) 创建一个简单的工程 --> Group Id:com.zj --> Artifact Id:ssm-crud --> Packaging:war --> Finish (此时项目没有web.xml)
(2) 项目右键 --> Properties --> Project Facets --> Dynamic Web Module 去掉√ --> Apply --> Dynamic Web Module 再点上√ --> 点下面的连接 --> 目录改为src/main/webapp --> OK (此时会为项目增加web.xml)
2. 引入项目依赖的jar包

spring
springmvc
mybatis
数据库连接池，驱动包
其他(jstl, servlet-api, junit)
2.1 pom.xml中引入jar包

可在 https://mvnrepository.com/ 搜索需要引入的jar包

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.zj</groupId>
  <artifactId>ssm-crud</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <packaging>war</packaging>
  
  <!-- 引入项目依赖的jar包 -->
  <dependencies>
	<!-- springmvc  spring -->
	<!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->
	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-webmvc</artifactId>
		<version>4.3.18.RELEASE</version>
	</dependency>
	<!-- spring jdbc -->
	<!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc -->
	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-jdbc</artifactId>
		<version>4.3.18.RELEASE</version>
	</dependency>
	<!-- spring 面向切面编程 spring aspects -->
	<!-- https://mvnrepository.com/artifact/org.springframework/spring-aspects -->
	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-aspects</artifactId>
		<version>4.3.18.RELEASE</version>
	</dependency>
	<!-- mybatis -->
	<!-- https://mvnrepository.com/artifact/org.mybatis/mybatis -->
	<dependency>
		<groupId>org.mybatis</groupId>
		<artifactId>mybatis</artifactId>
		<version>3.4.6</version>
	</dependency>
	<!-- mybatis整合spring的适配包 -->
	<!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring -->
	<dependency>
		<groupId>org.mybatis</groupId>
		<artifactId>mybatis-spring</artifactId>
		<version>1.3.2</version>
	</dependency>
	<!-- 数据库连接池 c3p0 、驱动 -->
	<!-- https://mvnrepository.com/artifact/com.mchange/c3p0 -->
	<dependency>
		<groupId>com.mchange</groupId>
		<artifactId>c3p0</artifactId>
		<version>0.9.5.2</version>
	</dependency>
	<!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java -->
	<dependency>
		<groupId>mysql</groupId>
		<artifactId>mysql-connector-java</artifactId>
		<version>5.1.47</version>
	</dependency>
		
	<!-- 其他(jstl, servlet-api, junit)  -->
	<!-- https://mvnrepository.com/artifact/javax.servlet/jstl -->
	<dependency>
		<groupId>javax.servlet</groupId>
		<artifactId>jstl</artifactId>
		<version>1.2</version>
	</dependency>
		
	<!-- servlet-api 注意加个 scope属性  provided -->
	<!-- https://mvnrepository.com/artifact/javax.servlet/servlet-api -->
	<dependency>
		<groupId>javax.servlet</groupId>
		<artifactId>servlet-api</artifactId>
		<version>2.5</version>
		<scope>provided</scope>
	</dependency>
	<!-- https://mvnrepository.com/artifact/junit/junit -->
	<dependency>
		<groupId>junit</groupId>
		<artifactId>junit</artifactId>
		<version>4.12</version>
		<scope>test</scope>
	</dependency>
  </dependencies>
  
</project>
3. 引入bootstrap前端框架 (搜索bootstrap中文网)

(1) 将下载的bootstrap文件夹整个的放到webapp/static下
(2) 建webapp/js，将jquery导入
(3) 在xxx.jsp中引入
	<!-- Bootstrap -->
	<link href="static/bootstrap-3.3.7-dist/css/bootstrap.min.css" rel="stylesheet">
	<!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) -->
	<script src="static/js/jquery-1.12.4.min.js"></script>
	<!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 -->
	<script src="static/bootstrap-3.3.7-dist/js/bootstrap.min.js"></script>
(4) 具体操作参考 https://v3.bootcss.com/css/
4. 编写ssm整合配置文件

web.xml,spring,springmvc,mybatis，使用mybatis的逆向工程生成对应的bean以及mapper
4.1 web.xml (src/main/webapp/WEB-INF/)

<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5">
	<!-- 1. 启动Spring的容器 -->
	<!-- needed for ContextLoaderListener -->
	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>classpath:applicationContext.xml</param-value>
	</context-param>

	<!-- Bootstraps the root web application context before servlet initialization -->
	<listener>
		<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
	</listener>
	
	<!-- 2. springmvc的前端控制器、拦截所有请求-->
	<!-- The front controller of this Spring Web application, responsible for handling all application requests -->
	<servlet>
		<servlet-name>dispatcherServlet</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<load-on-startup>1</load-on-startup>
	</servlet>

	<!-- Map all requests to the DispatcherServlet for handling -->
	<servlet-mapping>
		<servlet-name>dispatcherServlet</servlet-name>
		<url-pattern>/</url-pattern>
	</servlet-mapping>
	
	<!-- 3. 字符编码过滤器， 一定要放在所有过滤器前面 -->
	<filter>
		<filter-name>CharacterEncodingFilter</filter-name>
		<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
		<init-param>
			<param-name>encoding</param-name>
			<param-value>utf-8</param-value>
		</init-param>
		<init-param>
			<param-name>forceRequestEncoding</param-name>
			<param-value>true</param-value>
		</init-param>
		<init-param>
			<param-name>forceResponseEncoding</param-name>
			<param-value>true</param-value>
		</init-param>
	</filter>
	<filter-mapping>
		<filter-name>CharacterEncodingFilter</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>
	
	<!-- 4. 使用Rest风格的URI 将页面普通的post请求转为指定的delete或put请求-->
	<filter>
		<filter-name>HiddenHttpMethodFilter</filter-name>
		<filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>
	</filter>
	<filter-mapping>
		<filter-name>HiddenHttpMethodFilter</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>

</web-app>
4.2 dispatcherServlet-servlet.xml (src/main/webapp/WEB-INF/) (在此文件Namspaces页面需勾上 context、mvc、)

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:mvc="http://www.springframework.org/schema/mvc"
	xsi:schemaLocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd
		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd">

	<!-- SpringMVC 的配置文件，包含往左跳转逻辑的控制、配置 context -->
	<context:component-scan base-package="com.zj.sts" use-default-filters="false">
		<!-- 只扫描控制器 -->
		<context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
	</context:component-scan>
	
	<!-- 配置视图解析器， 方便页面返回 -->
	<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<property name="prefix" value="/WEB-INF/views/"></property>
		<property name="suffix" value=".jsp"></property>
	</bean>
	
	<!-- 两个标准配置 mvc -->
	<!-- 将springmvc不能处理的请求交给tomcat -->
	<mvc:default-servlet-handler/>
	<!-- 能支持springmvc更高级的一些功能, JSR303校验，快捷的ajax，映射动态请求 -->
	<mvc:annotation-driven/>
</beans>
4.3 applicationContext.xml (src/main/resources/)

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd
		http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd
		http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd">
	
	<context:component-scan base-package="com.zj.sts">
		<context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
	</context:component-scan>
	<!-- Spring配置文件， 主要配置和业务逻辑相关的 -->
	<!--================================= 数据源、事务控制=================================， -->
	<context:property-placeholder location="classpath:dbconfig.properties"/>
	<bean id="pooledDataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
		<property name="jdbcUrl" value="${jdbc.jdbcUrl}"></property>
		<property name="driverClass" value="${jdbc.driverClass}"></property>
		<property name="user" value="${jdbc.username}"></property>
		<property name="password" value="${jdbc.password}"></property>		
	</bean>
	
	<!-- ==================================配置 spring和 mybatis的整合================================= -->
	<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
		<!-- 指定mybatis全局配置文件的位置 -->
		<property name="configLocation" value="classpath:mybatis-config.xml"></property>
		<property name="dataSource" ref="pooledDataSource"></property>
		<!-- 指定 mybatis，mapper文件的位置 -->
		<property name="mapperLocations" value="classpath:mapper/*.xml"></property>
	</bean>
	
	<!-- 配置扫描器，将mybatis接口的实现加入到ioc容器中 -->
	<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
		<!-- 扫描所有dao接口的实现，加入到ioc容器中 -->
		<property name="basePackage" value="com.zj.sts.crud.dao"></property>
	</bean>
	<!-- ================================================================== -->
	
	<!-- =================================事务控制的配置================================= -->
	<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<!-- 控制住数据源 -->
		<property name="dataSource" ref="pooledDataSource"></property>
	</bean>
	
	<!-- 开启基于注解的事务，使用xnl配置形式的事务(必要主要的都是使用配置式) -->
	<aop:config>
		<!-- 切入点表达式 -->
		<aop:pointcut expression="execution(* com.zj.sts.crud.service..*(..))" id="txPoint"/>
		<!-- 配置事务增强 -->
		<aop:advisor advice-ref="txAdvice" pointcut-ref="txPoint"/>
	</aop:config>
	<!-- 配置事务增强，事务如何切入 -->
	<tx:advice id="txAdvice" transaction-manager="transactionManager">
		<tx:attributes>
			<!-- 所有方法都是事务方法 -->
			<tx:method name="*"/>
			<!-- 以get开始的所有方法 -->
			<tx:method name="get*" read-only="true"/>
		</tx:attributes>
	</tx:advice>
	
	<!-- Spring配置文件的核心点 (数据源、与mybatis的整合、事务控制) -->
	
</beans>
4.4 mybatis-config.xml (src/main/resources/)

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration
  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-config.dtd">

<configuration>
	<settings>
		<!-- 驼峰命名规则 -->
		<setting name="mapUnderscoreToCamelCase" value="true"/>
	</settings>
	<!-- 取别名 -->
	<typeAliases>
		<package name="com.zj.sts.crud.bean"/>
	</typeAliases>
</configuration>
4.5 配置mybatis generator, 建mbg.xml ()可参考 http://www.mybatis.org/generator/configreference/xmlconfig.html

在pom.xml中加入依赖

<!-- MBG -->
<!-- https://mvnrepository.com/artifact/org.mybatis.generator/mybatis-generator-core -->
<dependency>
	<groupId>org.mybatis.generator</groupId>
	<artifactId>mybatis-generator-core</artifactId>
	<version>1.3.7</version>
</dependency>
项目目录下创建 mbg.xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE generatorConfiguration
  PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
  "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">

<generatorConfiguration>

  <context id="DB2Tables" targetRuntime="MyBatis3">
	<!-- 配置数据库连接 -->
	<jdbcConnection driverClass="com.mysql.jdbc.Driver"
		connectionURL="jdbc:mysql://localhost:3306/ssm_crud"
		userId="root"
		password="root">
	</jdbcConnection>

	<javaTypeResolver >
	  <property name="forceBigDecimals" value="false" />
	</javaTypeResolver>
	
	<!-- 指定javaBean生成的位置 -->
	<javaModelGenerator targetPackage="com.zj.sts.crud.bean" targetProject=".\src\main\java">
	  <property name="enableSubPackages" value="true" />
	  <property name="trimStrings" value="true" />
	</javaModelGenerator>

	<!-- 指定sql映射文件生成的位置 -->
	<sqlMapGenerator targetPackage="mapper"  targetProject=".\src\main\resources">
	  <property name="enableSubPackages" value="true" />
	</sqlMapGenerator>
	
	<!-- 指定dao接口生成的位置，mapper接口 -->
	<javaClientGenerator type="XMLMAPPER" targetPackage="com.zj.sts.crud.dao"  targetProject=".\src\main\java">
	  <property name="enableSubPackages" value="true" />
	</javaClientGenerator>
	
	<!-- 指定每个表的生成策略 -->
	<table tableName="tab_emp" domainObjectName="Employee"></table>
	<table tableName="tab_dept" domainObjectName="Department"></table>

  </context>
</generatorConfiguration>
测试能否生成： 在测试包中建 MBGTest.java

public class MBGTest {

	public static void main(String[] args) throws Exception {
		List<String> warnings = new ArrayList<String>();
	   boolean overwrite = true;
	   File configFile = new File("mbg.xml");
	   ConfigurationParser cp = new ConfigurationParser(warnings);
	   Configuration config = cp.parseConfiguration(configFile);
	   DefaultShellCallback callback = new DefaultShellCallback(overwrite);
	   MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);
	   myBatisGenerator.generate(null);
	}
}
运行之后 bean dao 包中有生成则成功。此时生成的代码有很多注释。
在mbg.xml中配置 suppressAllComments， 则注释不会生成
<commentGenerator>
  <property name="suppressAllComments" value="true" />
</commentGenerator>
5. 测试mapper

导入Spring test模块 在 pom.xml中

<!-- Spring-test -->
<!-- https://mvnrepository.com/artifact/org.springframework/spring-test -->
<dependency>
	<groupId>org.springframework</groupId>
	<artifactId>spring-test</artifactId>
	<version>4.3.18.RELEASE</version>
</dependency>
在 applicationContext.xml 中配置一个可以 执行批量操作的SqlSession

<!-- 配置批量操作的 SqlSession -->
<bean class="org.mybatis.spring.SqlSessionTemplate" id="sqlSession">
	<constructor-arg name="sqlSessionFactory" ref="sqlSessionFactory"></constructor-arg>
	<constructor-arg name="executorType" value="BATCH"></constructor-arg>
</bean>
建立 MapperTest.java

package com.zj.sts.crud.test;

import java.util.UUID;

import org.apache.ibatis.session.SqlSession;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import com.zj.sts.crud.bean.Department;
import com.zj.sts.crud.bean.Employee;
import com.zj.sts.crud.dao.DepartmentMapper;
import com.zj.sts.crud.dao.EmployeeMapper;

/**
 * 测试dao层的工作
 * @author vinc
 *	推荐Spring的项目就可以使用Spring的单元测试，可以自动注入我们需要的组件
 *	1. 导入SpringTest模块
 *	2. @ContextConfiguration指定Spring配置文件的位置
 *	3. 直接autoWired要使用的组件即可
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations={"classpath:applicationContext.xml"})
public class MapperTest {

	@Autowired
	DepartmentMapper departmentMapper;
	
	@Autowired
	EmployeeMapper employeeMapper;
	
	@Autowired
	SqlSession sqlSession;
	@Test
	public void testCRUD() {
		/*
		 * // 1. 创建SpringIOC容器 ApplicationContext iocApplicationContext = new
		 * ClassPathXmlApplicationContext("applicationContext.xml"); //2. 从容器中获取mapper
		 * iocApplicationContext.getBean(DepartmentMapper.class);
		 */
		System.out.println(departmentMapper);
		
		//1. 插入几个部门
//		departmentMapper.insertSelective(new Department(null, "开发部"));
//		departmentMapper.insertSelective(new Department(null, "测试部"));
//		departmentMapper.insertSelective(new Department(null, "运维部"));
		
		//2. 增加几个员工
//		employeeMapper.insertSelective(new Employee(null, "jerry", "M", "jerry@122.com", 1));
		
		//3. 批量插入多个员工：批量，或者使用可以执行批量操作的sqlSession
//		for() {	//不推荐
//			employeeMapper.insertSelective(new Employee(null, "jerry", "M", "jerry@122.com", 1));
//		}
		EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class);
		for (int i = 0; i < 1000; i++) {
			String substring = UUID.randomUUID().toString().substring(0, 6) + i;
			mapper.insertSelective(new Employee(null, substring, "M", substring+"@163.COM", 1));
		}
		System.out.println("批量完成");
	}
}
四. 查询

1. 步骤

(1). 访问index.jsp页面
(2). index.jsp页面发送出查询员工列表请求
(3). EmployeeController来接收请求，查出员工数据
(4). 来到list.jsp页面进行展示
2. 详细操作

约定： uri: /emps
2.1 如何使用分页-pagehelper插件

pom.xml中加入依赖

<!-- 引入PageHelper分页插件 -->
	<dependency>
	    <groupId>com.github.pagehelper</groupId>
	    <artifactId>pagehelper</artifactId>
	    <version>5.1.8</version>
	</dependency>
mybatis-config.xml中配置插件

<plugins>
	<plugin interceptor="com.github.pagehelper.PageInterceptor"></plugin>
		<!-- 分页参数合理化 -->
		<property name="reasonable" value="true"></property>
</plugins>
</plugins>
2.2 Spring4测试的时候，需要servlet3.0的支持(pom.xml中更换)

<!-- servlet-api 注意加个 scope属性  provided -->
<!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api -->
<dependency>
	<groupId>javax.servlet</groupId>
	<artifactId>javax.servlet-api</artifactId>
	<version>3.0.1</version>
	<scope>provided</scope>
</dependency>
2.3 创建 EmployeeController.java (控制层)

package com.zj.sts.crud.controller;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam;

import com.github.pagehelper.PageHelper; import com.github.pagehelper.PageInfo; import com.zj.sts.crud.bean.Employee; import com.zj.sts.crud.service.EmployeeService; /**

处理员工的CRUD请求
@author vinc
*/ @Controller public class EmployeeController {

@Autowired
EmployeeService employeeService;
/**
 * 查询员工数据 （分页查询）
 * @return
 */
@RequestMapping("/emps")
public String getEmps(@RequestParam(value="pn", defaultValue="1") Integer pn, Model model) {
	
	//这不是一个分页查询
	//引入PageHelper分页插件
	//在查询之前只需调用，传入页码，以及每页大小
	PageHelper.startPage(pn, 5); 
	//startPage后面紧跟的这个查询就是 一个分页查询
	List<Employee> emps = employeeService.getAll();
	//使用pageInfo包装查询后的结果，只需要将PageInfo交给页面就行了
	//封装了详细的分页信息，包括有我们查询出来的数据,传入连续显示的页数
	PageInfo page = new PageInfo(emps, 5);
	model.addAttribute("pageInfo", page);
	
	return "list";
}
}

2.4 创建 EmployeeService.java (业务逻辑层)

package com.zj.sts.crud.service;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service;

import com.zj.sts.crud.bean.Employee; import com.zj.sts.crud.dao.DepartmentMapper; import com.zj.sts.crud.dao.EmployeeMapper;

@Service public class EmployeeService {

@Autowired
EmployeeMapper employeeMapper;

/**
 * 查询所有员工
 * @return
 */
public List<Employee> getAll() {
	// TODO Auto-generated method stub
	return employeeMapper.selectByExampleWithDept(null);
}
}

2.5 测试类 创建MvcTest.java

package com.zj.sts.crud.test;
import java.util.List;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.mock.web.MockHttpServletRequest;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.web.WebAppConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.MvcResult;
import org.springframework.test.web.servlet.RequestBuilder;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.web.context.WebApplicationContext;
import com.github.pagehelper.PageInfo;
import com.zj.sts.crud.bean.Employee;
/**
 * 使用Spring测试模块提供的测试请求功能，测试CRUD请求的正确性
 * Spring4测试的时候，需要servlet3.0的支持 
 * @author vinc
 *
 */
@RunWith(value=SpringJUnit4ClassRunner.class)
@WebAppConfiguration
@ContextConfiguration(locations= {"classpath:applicationContext.xml", "file:src/main/webapp/WEB-INF/dispatcherServlet-servlet.xml"})
public class MvcTest {
	//传入springmvc的ioc
	@Autowired
	WebApplicationContext webApplicationContext;
	//虚拟mvc请求，获取到处理结果
	MockMvc mockMvc;
	
	@Before
	public void initMockMvc() {
		mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build();
	}
	
	@Test
	public void testPage() throws Exception {
		//模拟请求拿到返回值
		MvcResult result = mockMvc.perform(MockMvcRequestBuilders.get("/emps").param("pn", "5")).andReturn();
		//请求成功后，请求域中会有PageInfo ,我们可以取出PageInfo进行验证
		MockHttpServletRequest request = result.getRequest();
		PageInfo pi = (PageInfo) request.getAttribute("pageInfo");
		System.out.println("当前页码： " + pi.getPageNum());
		System.out.println("总页码： " + pi.getPages());
		System.out.println("总记录数：  " + pi.getTotal());
		System.out.println("在页码需要连续显示的页码：");
		int[] nums = pi.getNavigatepageNums();
		for(int i:nums) {
			System.out.println(" " + i);
		}
		
		//获取员工数据
		List<Employee> list = pi.getList();
		for(Employee e:list) {
			System.out.println("ID: " + e.getEmpId() + ", name: " + e.getEmpName());
		}
	}
}
2.6 index.jsp页面

<%@ page language="java" contentType="text/html; charset=UTF-8"
pageEncoding="UTF-8"%>
<jsp:forward page="/emps"></jsp:forward>
2.7 list.jsp页面

<%
	pageContext.setAttribute("APP_PATH", request.getContextPath());//项目路径(以/开始，不以/结束)
%>
<!-- web路径：
	不以/开始的相对路径，找资源，以当前资源的路径为基准，经常容易出问题。
	以/开始的相对路径，找资源，以服务器的路径为标准(http://localhost:3306)，需要加上项目名
		http://localhost:3306/ssm-crud/
		src="${APP_PATH }/static/js/jquery-1.12.8.min.js"-->
2.8 list.jsp 页面详细代码

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>员工列表</title>
<%
	pageContext.setAttribute("APP_PATH", request.getContextPath());//项目路径(以/开始，不以/结束)
%>
<!-- web路径：
	不以/开始的相对路径，找资源，以当前资源的路径为基准，经常容易出问题。
	以/开始的相对路径，找资源，以服务器的路径为标准(http://localhost:3306)，需要加上项目名-->
<!-- Bootstrap -->
<link href="${APP_PATH }/static/bootstrap-3.3.7-dist/css/bootstrap.min.css" rel="stylesheet">
<!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) -->
<script src="${APP_PATH }/static/js/jquery-1.12.4.min.js"></script>
<!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 -->
<script src="${APP_PATH }/static/bootstrap-3.3.7-dist/js/bootstrap.min.js"></script>
</head>
<body>
	<!-- 显示搭建页面 -->
	<div class="container">
		<!-- 标题 -->
		<div class="row">
			<div class="col-md-12">
				<h1>SSM-CRUD</h1>
			</div>
		</div>
		<!-- 按钮 -->
		<div class="row">
			<div class="col-md-4 col-md-offset-8">
				<button class="btn btn-primary">新增</button>
				<button class="btn btn-danger">删除</button>
			</div>
		</div>
		<!-- 表格数据 -->
		<div class="row">
			<div class="col-md-12">
				<table class="table table-hover">
					<tr>
						<th>#</th>
						<th>empName</th>
						<th>gender</th>
						<th>email</th>
						<th>deptName</th>
						<th>操作</th>
					</tr>
					<c:forEach items="${pageInfo.list }" var="emp">
						<tr>
							<th>${emp.empId }</th>
							<th>${emp.empName }</th>
							<th>${emp.gender=="M"?"男":"女" }</th>
							<th>${emp.email }</th>
							<th>${emp.department.deptName }</th>
							<th>
								<button class="btn btn-primary btn-sm">
									 <span class="glyphicon glyphicon-pencil" aria-hidden="true"></span>
									修改
								</button>
								<button class="btn btn-danger btn-sm">
									 <span class="glyphicon glyphicon-trash" aria-hidden="true"></span>
									删除
								</button>
							</th>
						</tr>
					
					</c:forEach>
				</table>
			</div>
		</div>
		<!-- 分页信息 -->
		<div class="row">
			<!-- 当前信息 -->
			<div class="col-md-6">
				当前第${pageInfo.pageNum }页 总${pageInfo.pages }页 总${pageInfo.total }条记录数
			</div>
			<!-- 分页信息 -->
			<div class="col-md-6">
				<nav aria-label="Page navigation">
				  <ul class="pagination">
				  	<li><a href="${APP_PATH }/emps?pn=1">首页</a></li>
				  	<c:if test="${pageInfo.hasPreviousPage }">
					    <li>
					      <a href="${APP_PATH }/emps?pn=${pageInfo.pageNum-1}" aria-label="Previous">
					        <span aria-hidden="true">&laquo;</span>
					      </a>
					    </li>
				  	</c:if>
				    <c:forEach items="${pageInfo.navigatepageNums }" var="page_Num">
				    	<c:if test="${page_Num == pageInfo.pageNum }">
					    	<li class="active"><a href="#">${page_Num }</a></li>
				    	</c:if>
				    	<c:if test="${page_Num != pageInfo.pageNum }">
					    	<li><a href="${APP_PATH }/emps?pn=${page_Num}">${page_Num }</a></li>
				    	</c:if>
				    </c:forEach>
				    <c:if test="${pageInfo.hasNextPage }">
					    <li>
					      <a href="${APP_PATH }/emps?pn=${pageInfo.pageNum+1}" aria-label="Next">
					        <span aria-hidden="true">&raquo;</span>
					      </a>
					    </li>
				    </c:if>
				    <li><a href="${APP_PATH }/emps?pn=${pageInfo.pages}">末页</a></li>
				  </ul>
				</nav>
			</div>
		</div>
	</div>

</body>
</html>
2.8 访问

部署启动tomat，浏览器中打开 http://localhost:8080/ssm-crud/index.jsp
五. 查询-ajax

(1). index.jsp页面直接发送ajax请求进行员工分页数据的查询
(2). 服务器将查询出的数据，以json字符串的形式返回给浏览器
(3). 浏览器收到json字符串，可以使用js对json进行解析，使用js通过dom增删改改变页面
(4). 返回json,实现客户端的无关性
0. 导入jackson依赖 pom.xml

<!-- 返回json字符串的支持 -->
<!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind -->
<dependency>
	<groupId>com.fasterxml.jackson.core</groupId>
	<artifactId>jackson-databind</artifactId>
	<version>2.9.4</version>
</dependency>
1. EmployeeController.java

package com.zj.sts.crud.controller;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import com.github.pagehelper.PageHelper;
import com.github.pagehelper.PageInfo;
import com.zj.sts.crud.bean.Employee;
import com.zj.sts.crud.service.EmployeeService;
/**
  *   处理员工的CRUD请求
 * @author vinc
 *
 */
@Controller
public class EmployeeController {

	@Autowired
	EmployeeService employeeService;
	
	/**
	 * 导入jackson包， 然后ResponseBody负责将对象转为 json
	 * @param pn
	 * @return
	 */
	@RequestMapping("/emps")
	@ResponseBody
	public PageInfo getEmpsWithJson(@RequestParam(value="pn", defaultValue="1") Integer pn) {
		//这不是一个分页查询
		//引入PageHelper分页插件
		//在查询之前只需调用，传入页码，以及每页大小
		PageHelper.startPage(pn, 5); 
		//startPage后面紧跟的这个查询就是 一个分页查询
		List<Employee> emps = employeeService.getAll();
		//使用pageInfo包装查询后的结果，只需要将PageInfo交给页面就行了
		//封装了详细的分页信息，包括有我们查询出来的数据,传入连续显示的页数
		PageInfo page = new PageInfo(emps, 5);
		return page;
	}
}
2. 访问

部署启动tomat，浏览器中打开 http://localhost:8080/ssm-crud/index.jsp
此时页面显示的是json字符串
3. 新建 Msg.java

package com.zj.sts.crud.bean;

import java.util.HashMap;
import java.util.Map;

/**
 * 通用的返回类
 * @author vinc
 *
 */
public class Msg {

	//状态码 100-成功  200-失败
	private int code;
	
	//提示信息
	private String msg;
	
	//用户要返回给浏览器的数据
	private Map<String, Object> extend = new HashMap<String, Object>();

	public static Msg success() {
		Msg result = new Msg();
		result.setCode(100);
		result.setMsg("处理成功！");
		return result;
	}
	
	public static Msg fail() {
		Msg result = new Msg();
		result.setCode(200);
		result.setMsg("处理失败！");
		return result;
	}
	
	public Msg add(String key, Object value) {
		this.getExtend().put(key, value);
		return this;
	}
	// get set  方法
}
4. 改写 EmployeeController.java 中的方法

@RequestMapping("/emps")
@ResponseBody
public Msg getEmpsWithJson(@RequestParam(value="pn", defaultValue="1") Integer pn) {
	//这不是一个分页查询
	//引入PageHelper分页插件
	//在查询之前只需调用，传入页码，以及每页大小
	PageHelper.startPage(pn, 5); 
	//startPage后面紧跟的这个查询就是 一个分页查询
	List<Employee> emps = employeeService.getAll();
	//使用pageInfo包装查询后的结果，只需要将PageInfo交给页面就行了
	//封装了详细的分页信息，包括有我们查询出来的数据,传入连续显示的页数
	PageInfo page = new PageInfo(emps, 5);
	return Msg.success().add("pageInfo", page);
}
5. 新建一个index.jsp页面，将原有的更改为index-2.jsp

复制list.jsp页面内容到index.jsp，改写index.jsp
六. 新增

(1). 在 index.jsp 页面点新增
(2). 弹出新增对话框
(3). 去数据库查询部门列表显示在对话框中
(4). 用户输入数据,并进行校验
	 jQuery前端校验，ajax用户名重复校验，重要数据(后端校验(JSR303),唯一约束)
(5). 完成保存

URI:	约定
	/emp/{id}	GET 查询员工
	/emp		POST 保存员工
	/emp/{id}	PUT	 修改员工
	/emp/{id}	DELETE 删除员工
员工保存：

支持JSR303校验
导入Hibernate-Validator
pom.xml
跳转逻辑：

**.jsp --> dispatcherServlet-servlet.xml --> controller --> service --> dao(mapper) --> xxxMapper.xml

七. 修改

(1). 点击编辑
(2). 弹出用户修改的模态框(显示用户信息)
(3). 点击更新，完成用户修改
(4).
八. 删除

(1). 单个删除
(2). 批量删除(全选/全不选)
(3).
(4).

dom原生的属性使用prop()获取，自定义属性使用attr()获取
使用prop修改和读取dom元素原生属性的值
attr获取checked 属性是undefined
九. 注

/**
 * 如果直接发送ajax=PUT形式的请求
 * 封装的数据，除了路径中带的值，其余均为null
 * 
 * 问题：
 * 请求体中有数据，但是Employee对象封装不上，
 * 
 * 原因：
 * Tomcat：
 * 		1. 将请求体中的数据，封装成一个map。
 * 		2. request.getParameter("empName")就会从这个map中取值
 * 		3. SpringMVC封装POJO对象的时候
 * 				会把POJO中每个属性的值，request.getParameter("email");
 * ajax发送put请求引发的问题：
 * 		PUT 请求，请求体重的数据，request.getParameter("empName")拿不到值
 * 		Tomcat 一看是PUT不会封装请求体重的数据为map，只有POST请求才封装请求体为map
 * 	
 * 解决方案：
 * 我们要能支持直接发送PUT之类的请求还要封装请求体中的数据
 *  1. 配置上HttpPutFormContentFilter， (web.xml)
 * 	2. 作用：将请求体中的数据解析包装成一个map，request被重新包装
 *  3. request.getParameter()被重写就会从封装的map中取数据
 *
